# 数据结构与算法
### 1.最大子列和问题
```C
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
int main()
{
    int numsSize,sum,result;
    
    scanf("%d",&numsSize);
    int* nums = malloc(sizeof(int) * numsSize);
    for (int i = 0; i < numsSize; i++) {
        scanf("%d", &nums[i]);
    }
    result = 0;
    sum = 0;
    for (int i =i; i < numsSize; i++) {
        sum = fmax(sum + nums[i],nums[i]);
        result = fmax(sum,result);
    }
    printf("%d",result);
    return 0;
}
```
### 习题1.8 二分查找（编程题）
#### 代码
``` C
Position BinarySearch( List L, ElementType X )
{
    Position left = 1, right = L->Last, mid;
    while (left <= right) {
        mid = (left + right) / 2;
        if ((L->Data)[mid] < X)
            left = mid + 1;
        else if ((L->Data)[mid] > X)
            right = mid - 1;
        else
            return mid;
    }
    return NotFound;
}
```

### 习题2.4 递增的整数序列链表的插入
>浙大版《数据结构（第2版）》题目集
#### 代码
```C
struct Node* insert(struct Node* head)
{
	struct Node* Pt,* Pt1,* Pt2;

	Pt = (struct Node*)malloc(sizeof(struct Node));
	printf("Please input number:");
	scanf_s("%d", &Pt->date);
	if (Pt->date < head->date) {
		Pt->next = head;
		return Pt;
	}
	Pt1 = head;
	Pt2 = head->next;
	while (Pt2) {
		if (Pt1->date < Pt->date && Pt->date < Pt2->date)
		{
			Pt1->next = Pt;
			Pt->next = Pt2;
			break;
		}
		Pt1 = Pt1->next;
		Pt2 = Pt1->next;
	}
	if (Pt2 == NULL) {
		Pt1->next = Pt;
		Pt->next = NULL;
	}
	return head;
}
```
## 第二周
### 案例1.
![image](https://user-images.githubusercontent.com/73301646/221337040-18c11f87-4e66-4c19-95e6-f50352fd9bc7.png)
错因：
* 全局变量和局部变量冲突的时候，函数体内用的是局部变量的值。

改进：
* 去掉函数定义时的int top
### 案例2.
![image](https://user-images.githubusercontent.com/73301646/221339019-158b98d4-5b18-4613-bc66-c54363596149.png)
2 * (9 + 6/3 - 5 + 4)


































Study/数据结构与算法/数据结构与算法.md
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc4MTg1MDUxOSw3MTgxMDE4NzUsLTE3MT
g3NjQ5ODcsNjc4NjkwMjE4LC05ODY1ODMwNDAsLTQ0MDM5NjUz
Ml19
-->