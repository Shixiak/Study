# 数据结构与算法
## 第一周
### 实例1.1 最大子列和问题
>浙大版《数据结构（第2版）》题目集
#### 我自己的菜鸡解法
```C
#include <stdio.h>
#include <stdlib.h>

int count;
int* readlist(void);
int Getmax(int* L);

int main()
{
	int* L, max;
	L = readlist();
	max = Getmax(L);
	printf("The max = %d\n", max);
	return 0;
}

int* readlist(void)
{
	int* L;

	scanf_s("%d", &count);
	L = (int*)malloc(sizeof(int) * count);
	if (L == NULL) exit(-1);
	for (int i = 0; i < count; i++)
		scanf_s("%d", L+i);

	return L;
}
//我自己的菜鸡解法
int Getmax(int* L)
{
	int max = 0, result;

	for (int i = 0; i < count; i++)
	{
		result = 0;
		for (int j = i; j < count; j++) {
			result += L[j];
			if (result > max) {
				max = result;
			}
		}
	}

	return max;
}
```
个人认为最不满意的地方就是用了全局变量，但是苦于难以在子函数中获得数组长度，不得已而为之。
* 通过传递数组名到子函数中，以获得数组长都是不可取的；
####  大佬的解答
```C
int MaxSubseqSum4(int A[], int N)
{
	int thissum = 0, maxsum = 0;
	int i;

	for (i = 0; i < N; i++)
	{
		thissum += A[i];
		if (thissum > maxsum)
			maxsum = thissum;
		else if (thissum < 0)
			thissum = 0;
	}
	return maxsum;
}
//如果有一个数小到能够抵消此前所有正数，那么下次累加就可以从这个负数之后进行运算
//我愿称之为绝妙
```
收获：
* 通过向子函数传入形参数组名，无法用sizeof(L)/sizeof(sizeof[0]) 的方式获取数组长度
* 大佬的解答是真的nb啊
* 路漫漫其修远兮，吾将上下而求索
### 习题1.8 二分查找
> 浙大版《数据结构（第2版）》题目集
#### 代码
``` C
int BinarySearch(int a[], int length, int target)
{
	int left = 0, right = length, mid;
	while (left < right) 
	{
		mid = (left + right) / 2;
		if (a[mid] < target)
			left = mid + 1;
		else if (target < a[mid])
			right = mid - 1;
		else
			break;
	}
	if (left > right)
		return -1;
	else
		return mid;
}
```
### 习题2.4 递增的整数序列链表的插入
>浙大版《数据结构（第2版）》题目集
#### 代码
```C
struct Node* insert(struct Node* head)
{
	struct Node* Pt,* Pt1,* Pt2;

	Pt = (struct Node*)malloc(sizeof(struct Node));
	printf("Please input number:");
	scanf_s("%d", &Pt->date);
	if (Pt->date < head->date) {
		Pt->next = head;
		return Pt;
	}
	Pt1 = head;
	Pt2 = head->next;
	while (Pt2) {
		if (Pt1->date < Pt->date && Pt->date < Pt2->date)
		{
			Pt1->next = Pt;
			Pt->next = Pt2;
			break;
		}
		Pt1 = Pt1->next;
		Pt2 = Pt1->next;
	}
	if (Pt2 == NULL) {
		Pt1->next = Pt;
		Pt->next = NULL;
	}
	return head;
}
```
## 第二周
### 案例1.
![image](https://user-images.githubusercontent.com/73301646/221337040-18c11f87-4e66-4c19-95e6-f50352fd9bc7.png)
错因：
* 全局变量和局部变量冲突的时候，函数体内用的是局部变量的值。

改进：
* 去掉函数定义时的int top
### 案例2.
![image](https://user-images.githubusercontent.com/73301646/221338441-ccc1dfbe-e867-4c4a-9e11-1815dec0545a.png)
中缀表达式：2*(6/3+4)-5
后缀表达式：



































Study/数据结构与算法/数据结构与算法.md
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMzk4NTE5MTMsLTk4NjU4MzA0MCwtND
QwMzk2NTMyXX0=
-->